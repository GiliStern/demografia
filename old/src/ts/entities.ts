// Entities: Entity, Player, Enemy, Pickup, Projectile (TS port)

class EntityTS {
  x: number; y: number; vx = 0; vy = 0; size = 16; radius = 16;
  health = 100; maxHealth = 100; shouldRemove = false; invulnerable = false; invulnerabilityTime = 0;
  color = '#ffffff'; scale = 1.0; rotation = 0; opacity = 1.0;
  animationFrame = 0; animationTime = 0; animationSpeed = 0.2; animationFrameCount = 4; animator: any;
  constructor(x: number, y: number) { this.x = x; this.y = y; this.radius = this.size; this.animator = new (window as any).FrameAnimator(); }
  update(deltaTime: number): void {
    if ((this as any) instanceof (window as any).Player && (this.vx !== 0 || this.vy !== 0)) {
      const movement = { x: this.vx * deltaTime, y: this.vy * deltaTime };
      console.log('Position update:', { deltaTime, velocity: { x: this.vx, y: this.vy }, movement, oldPosition: { x: this.x, y: this.y } });
    }
    this.x += this.vx * deltaTime; this.y += this.vy * deltaTime;
    if ((this as any) instanceof (window as any).Player && (this.vx !== 0 || this.vy !== 0)) console.log('New position:', { x: this.x, y: this.y });
    if (this.invulnerable) { this.invulnerabilityTime -= deltaTime; if (this.invulnerabilityTime <= 0) this.invulnerable = false; }
    this.animator.update(deltaTime); this.animationFrame = this.animator.getFrame();
  }
  render(ctx: CanvasRenderingContext2D): void { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.scale(this.scale, this.scale); ctx.globalAlpha = this.opacity; if (this.invulnerable && Math.floor(this.invulnerabilityTime * 10) % 2 === 0) ctx.globalAlpha *= 0.5; this.draw(ctx); ctx.restore(); if ((window as any).Debug?.enabled) this.renderDebug(ctx); }
  draw(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); }
  renderDebug(ctx: CanvasRenderingContext2D): void { ctx.save(); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); if (this.health < this.maxHealth) { const barWidth = this.size * 2; const barHeight = 4; const pct = this.health / this.maxHealth; ctx.fillStyle = '#ff0000'; ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 10, barWidth, barHeight); ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 10, barWidth * pct, barHeight); } ctx.restore(); }
  takeDamage(damage: number): boolean { if (this.invulnerable) return false; this.health -= damage; if (this.health <= 0) { this.health = 0; this.onDeath(); } return true; }
  heal(amount: number): void { this.health = Math.min(this.health + amount, this.maxHealth); }
  setInvulnerable(duration: number): void { this.invulnerable = true; this.invulnerabilityTime = duration; }
  onDeath(): void { this.shouldRemove = true; }
  getDistance(other: any): number { return (window as any).MathUtils.distance(this.x, this.y, other.x, other.y); }
  getAngleTo(other: any): number { return (window as any).MathUtils.angle(this.x, this.y, other.x, other.y); }
}

class PlayerTS extends EntityTS {
  characterData: any; baseSpeed = 0; moveSpeed = 0; level = 1; xp = 0; xpToNext = 100; totalXPGained = 0; gold = 0; goldEarned = 0;
  damageMultiplier = 1.0; areaMultiplier = 1.0; cooldownMultiplier = 1.0; speedMultiplier = 1.0; damageReduction?: number; healthRegen?: number;
  buffs = new Map<string, any>(); knockbackVelocity = new (window as any).Vector2(0, 0); knockbackDecay = 0.9; inputManager: any = null; facing = 1; spriteId = '';
  constructor(x: number, y: number, characterData: any) { super(x, y); this.characterData = characterData; this.size = 16; this.radius = 12; this.maxHealth = characterData.stats?.hp || 100; this.health = this.maxHealth; this.baseSpeed = (window as any).GAME_CONFIG.INPUT.MOVE_SPEED; const stat = characterData.stats?.move_speed ?? 1; this.moveSpeed = Math.max(this.baseSpeed * stat, 80); this.damageMultiplier = 1.0 + (characterData.stats?.might || 0) / 100; this.areaMultiplier = 1.0 + (characterData.stats?.area || 0) / 100; this.cooldownMultiplier = 1.0 - (characterData.stats?.cooldown || 0) / 100; this.inputManager = null; this.facing = 1; this.spriteId = `character_${characterData.id}`; console.log('Player created:', characterData.name_he); }
  update(deltaTime: number): void { this.handleInput(deltaTime); this.updateBuffs(deltaTime); this.updateKnockback(deltaTime); super.update(deltaTime); this.animationFrame = this.animator.getFrame(); if (this.vx > 0) this.facing = 1; else if (this.vx < 0) this.facing = -1; const margin = 2000; this.x = (window as any).MathUtils.clamp(this.x, -margin, margin); this.y = (window as any).MathUtils.clamp(this.y, -margin, margin); }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private handleInput(_deltaTime: number): void { if (!this.inputManager) { console.warn('Player: No input manager connected'); this.vx = 0; this.vy = 0; return; } const input = this.inputManager.getMovementInput(); const totalSpeed = this.moveSpeed * this.speedMultiplier; this.vx = input.x * totalSpeed; this.vy = input.y * totalSpeed; const moving = Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1; const meta = (window as any).spriteManager?.spriteMeta?.get(this.spriteId); const frameCount = Math.max(1, meta?.frameCount || 1); if (!moving || frameCount === 1) this.animator.setSequence([0], 8, 'idle'); else { const seq: number[] = []; for (let i = 1; i < frameCount; i++) seq.push(i); this.animator.setSequence(seq, 10, 'walk'); } }
  private updateBuffs(deltaTime: number): void { for (const [buffType, buff] of this.buffs) { buff.duration -= deltaTime; if (buff.duration <= 0) this.removeBuff(buffType); } }
  private updateKnockback(deltaTime: number): void { if (this.knockbackVelocity.magnitude() > 1) { this.x += this.knockbackVelocity.x * deltaTime; this.y += this.knockbackVelocity.y * deltaTime; this.knockbackVelocity.multiply(this.knockbackDecay); if (this.knockbackVelocity.magnitude() < 0.5) this.knockbackVelocity.set(0, 0); } }
  applyKnockback(angle: number, force: number): void { const knock = (window as any).Vector2.fromAngle(angle, force); this.knockbackVelocity.add(knock); }
  applyTemporaryBuff(type: string, multiplier: number, duration: number): void { this.buffs.set(type, { multiplier, duration, originalValue: this.getStatValue(type) }); this.updateStatMultipliers(); }
  removeBuff(type: string): void { this.buffs.delete(type); this.updateStatMultipliers(); }
  private updateStatMultipliers(): void { this.speedMultiplier = 1.0; this.damageMultiplier = 1.0 + (this.characterData.stats?.might || 0) / 100; for (const [buffType, buff] of this.buffs) { switch (buffType) { case 'speed': this.speedMultiplier *= buff.multiplier; break; case 'damage': this.damageMultiplier *= buff.multiplier; break; case 'invincible': this.setInvulnerable(buff.duration); break; } } }
  private getStatValue(type: string): number { switch (type) { case 'speed': return this.moveSpeed; case 'damage': return this.damageMultiplier; default: return 1.0; } }
  gainXP(amount: number): void { this.xp += amount; this.totalXPGained += amount; while (this.xp >= this.xpToNext) this.levelUp(); (window as any).saveSystem.updateSessionStats({ experienceGained: this.totalXPGained }); }
  private levelUp(): void { this.xp -= this.xpToNext; this.level++; this.xpToNext = Math.floor(this.xpToNext * 1.2); this.showLevelUpOptions(); const audio = (window as any).getAudioManager ? (window as any).getAudioManager() : null; audio?.playLevelUp?.(); this.heal(this.maxHealth * 0.1); console.log('Level up!', this.level); }
  private showLevelUpOptions(): void { const options = this.generateLevelUpOptions(); if ((window as any).gameEngine) (window as any).gameEngine.pauseGame(); if ((window as any).screenManager?.uiManager) { (window as any).screenManager.uiManager.showLevelUpPanel(options, (selected: any) => { this.applyLevelUpChoice(selected); (window as any).gameEngine?.resumeGame?.(); }); } }
  private generateLevelUpOptions(): any[] { const options: any[] = []; const weapons = (window as any).getWeapons(); const passives = (window as any).getPassives(); const weaponIds = Object.keys(weapons); for (let i = 0; i < 2; i++) { const weaponId = (window as any).MathUtils.randomChoice(weaponIds); const weapon = weapons[weaponId]; options.push({ type: 'weapon', id: weaponId, name: weapon.name_he, description: weapon.description_he }); } const passiveIds = Object.keys(passives); const passiveId = (window as any).MathUtils.randomChoice(passiveIds); const passive = passives[passiveId]; options.push({ type: 'passive', id: passiveId, name: passive.name_he, description: passive.description_he || 'Passive upgrade' }); return options; }
  private applyLevelUpChoice(option: any): void { switch (option.type) { case 'weapon': if ((window as any).gameEngine?.weaponSystem) (window as any).gameEngine.weaponSystem.addWeapon(option.id, this); break; case 'passive': this.applyPassiveUpgrade(option.id); break; } }
  private applyPassiveUpgrade(passiveId: string): void { switch (passiveId) { case 'spinach': this.damageMultiplier += 0.2; break; case 'armor': this.damageReduction = (this.damageReduction || 0) + 0.1; break; case 'hollow_heart': this.maxHealth += 20; this.heal(20); break; case 'pummarola': this.healthRegen = (this.healthRegen || 0) + 1; break; case 'wings': this.moveSpeed += 20; break; default: console.log('Applied passive:', passiveId); } }
  gainGold(amount: number): void { this.gold += amount; this.goldEarned += amount; (window as any).saveSystem.updateSessionStats({ goldEarned: this.goldEarned }); (window as any).saveSystem.updateProgress({ player: { gold: (window as any).saveSystem.progress.player.gold + amount } }); }
  takeDamage(damage: number): boolean { const actual = damage * (1 - (this.damageReduction || 0)); console.log('Player taking damage:', damage, '->', actual, 'Health before:', this.health); const taken = super.takeDamage(actual); if (taken) { console.log('Player health after damage:', this.health, '/', this.maxHealth); this.setInvulnerable(0.5); (window as any).saveSystem.updateSessionStats({ damageDealt: ((window as any).saveSystem.currentSession?.stats.damageDealt || 0) + actual }); } return taken; }
  draw(ctx: CanvasRenderingContext2D): void { const spriteId = this.spriteId; if ((window as any).spriteManager.getSprite(spriteId)) { ctx.save(); const scale = this.facing; ctx.scale(scale, 1); (window as any).spriteManager.drawSprite(ctx, spriteId, -this.size, -this.size, this.size * 2, this.size * 2, this.animationFrame); ctx.restore(); } else { super.draw(ctx); } const barWidth = this.size * 4; const barHeight = 6; const healthPercent = (window as any).MathUtils.clamp(this.health / this.maxHealth, 0, 1); const barX = -barWidth / 2; const barY = this.size + 10; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2); ctx.fillStyle = '#4a0000'; ctx.fillRect(barX, barY, barWidth, barHeight); ctx.fillStyle = '#00c853'; ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight); }
}

class EnemyTS extends EntityTS {
  enemyData: any; damage: number; moveSpeed: number; xpReward: number; knockback: number; target: any = null; attackCooldown = 0; attackRate: number; spriteId = ''; color = '#ff4757'; dropTable: any[]; isBoss?: boolean;
  constructor(x: number, y: number, enemyData: any) { super(x, y); this.enemyData = enemyData; this.size = 14; this.radius = 12; this.health = enemyData.health || 10; this.maxHealth = this.health; this.damage = enemyData.damage || 10; this.moveSpeed = enemyData.speed || 50; this.xpReward = enemyData.xpReward || 1; this.knockback = enemyData.knockback || 30; this.attackRate = enemyData.attackRate || 1.0; this.spriteId = `enemy_${enemyData.id}`; this.animator = new (window as any).FrameAnimator(); this.dropTable = enemyData.dropTable || [ { type: 'xp', value: 1, chance: 1.0 }, { type: 'gold', value: 1, chance: 0.1 }, ]; }
  update(deltaTime: number): void { if ((window as any).gameEngine?.player) this.target = (window as any).gameEngine.player; this.updateAI(deltaTime); if (this.attackCooldown > 0) this.attackCooldown -= deltaTime; const meta = (window as any).spriteManager?.spriteMeta?.get(this.spriteId); const frameCount = Math.max(1, meta?.frameCount || 1); const moving = Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1; if (!moving || frameCount === 1) this.animator.setSequence([0], 6, 'idle'); else { const seq: number[] = []; for (let i = 1; i < frameCount; i++) seq.push(i); this.animator.setSequence(seq, 8, 'walk'); } this.animator.update(deltaTime); this.animationFrame = this.animator.getFrame(); super.update(deltaTime); }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private updateAI(_deltaTime: number): void { if (!this.target) return; const angle = this.getAngleTo(this.target); const distance = this.getDistance(this.target); if (distance > this.radius + this.target.radius + 5) { this.vx = Math.cos(angle) * this.moveSpeed; this.vy = Math.sin(angle) * this.moveSpeed; } else { this.vx = 0; this.vy = 0; } }
  draw(ctx: CanvasRenderingContext2D): void { const spriteId = this.spriteId; if ((window as any).spriteManager.getSprite(spriteId)) { (window as any).spriteManager.drawSprite(ctx, spriteId, -this.size, -this.size, this.size * 2, this.size * 2, this.animationFrame); } else { this.drawFallback(ctx); } }
  private drawFallback(ctx: CanvasRenderingContext2D): void { if (this.enemyData.name_he.includes('חתול')) { ctx.fillStyle = '#FF7F50'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#FF6347'; ctx.beginPath(); ctx.moveTo(-8, -8); ctx.lineTo(-4, -12); ctx.lineTo(-12, -8); ctx.fill(); ctx.beginPath(); ctx.moveTo(8, -8); ctx.lineTo(4, -12); ctx.lineTo(12, -8); ctx.fill(); ctx.fillStyle = '#00ff00'; ctx.fillRect(-4, -4, 2, 2); ctx.fillRect(2, -4, 2, 2); } else if (this.enemyData.name_he.includes('טיקטוק')) { ctx.fillStyle = '#ff1493'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(-6, -8, 4, 6); } else { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(-3, -3, 1, 1); ctx.fillRect(2, -3, 1, 1); } }
}

class PickupTSTS extends EntityTS {
  type: string; value: number; pulseTime = 0; floatOffset = Math.random() * Math.PI * 2; lifetime = 30; magnetRange = 80; magnetSpeed = 100; spriteId = '';
  constructor(x: number, y: number, type: string, value: number) { super(x, y); this.type = type; this.value = value; this.size = 8; this.radius = 16; this.setAppearance(); }
  private setAppearance(): void { switch (this.type) { case 'xp': this.color = '#3498db'; this.spriteId = 'pickup_xp'; break; case 'gold': this.color = '#f1c40f'; this.spriteId = 'pickup_gold'; break; case 'health': this.color = '#e74c3c'; this.spriteId = 'pickup_health'; break; case 'powerup': this.color = '#9b59b6'; this.spriteId = 'pickup_powerup'; break; default: this.color = '#ffffff'; this.spriteId = 'pickup_generic'; } }
  update(deltaTime: number): void { this.lifetime -= deltaTime; if (this.lifetime <= 0) { this.shouldRemove = true; return; } this.pulseTime += deltaTime * 3; this.scale = 1.0 + Math.sin(this.pulseTime) * 0.2; this.y += Math.sin(this.pulseTime + this.floatOffset) * 10 * deltaTime; if ((window as any).gameEngine?.player) { const player = (window as any).gameEngine.player; const distance = this.getDistance(player); if (distance <= this.magnetRange) { const angle = this.getAngleTo(player); this.vx = Math.cos(angle) * this.magnetSpeed; this.vy = Math.sin(angle) * this.magnetSpeed; } } super.update(deltaTime); }
  draw(ctx: CanvasRenderingContext2D): void { if (this.lifetime < 5) ctx.globalAlpha *= this.lifetime / 5; if ((window as any).spriteManager.getSprite(this.spriteId)) { (window as any).spriteManager.drawSprite(ctx, this.spriteId, -this.size, -this.size, this.size * 2, this.size * 2); } else { this.drawFallback(ctx); } }
  private drawFallback(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = this.color; switch (this.type) { case 'xp': ctx.beginPath(); ctx.moveTo(0, -this.size); ctx.lineTo(this.size * 0.7, -this.size * 0.3); ctx.lineTo(this.size * 0.7, this.size * 0.3); ctx.lineTo(0, this.size); ctx.lineTo(-this.size * 0.7, this.size * 0.3); ctx.lineTo(-this.size * 0.7, -this.size * 0.3); ctx.closePath(); ctx.fill(); break; case 'gold': ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffd700'; ctx.font = `${this.size}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('₪', 0, 0); break; case 'health': ctx.fillRect(-this.size * 0.3, -this.size, this.size * 0.6, this.size * 2); ctx.fillRect(-this.size, -this.size * 0.3, this.size * 2, this.size * 0.6); break; default: ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); } }
}

class ProjectileTS extends EntityTS {
  angle: number; speed: number; damage: number; pierceCount: number; lifetime: number; homing: boolean; homingStrength: number; color = '#ffff00'; trail = false; trailPoints: Array<{ x: number; y: number; alpha: number }> = []; weaponType = 'generic';
  constructor(x: number, y: number, angle: number, speed: number, damage: number, projectileData: any = {}) { super(x, y); this.angle = angle; this.speed = speed; this.damage = damage; this.size = projectileData.size || 4; this.radius = this.size; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.piercing = projectileData.piercing || false; this.pierceCount = projectileData.pierceCount || 0; this.lifetime = projectileData.lifetime || 5.0; this.homing = projectileData.homing || false; this.homingStrength = projectileData.homingStrength || 0.1; this.color = projectileData.color || '#ffff00'; this.trail = projectileData.trail || false; this.rotation = angle; this.weaponType = projectileData.weaponType || 'generic'; this.animator = new (window as any).FrameAnimator(); this.animator.setSequence([0, 1], 12, 'weaponLoop'); }
  piercing: boolean;
  update(deltaTime: number): void { this.lifetime -= deltaTime; if (this.lifetime <= 0) { this.shouldRemove = true; return; } if (this.homing && (window as any).gameEngine) { const nearest = (window as any).gameEngine.getNearestEnemy(this.x, this.y, 200); if (nearest) { const targetAngle = this.getAngleTo(nearest); let diff = targetAngle - this.angle; while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2; this.angle += diff * this.homingStrength * deltaTime; this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed; this.rotation = this.angle; } } if (this.trail) { this.trailPoints.push({ x: this.x, y: this.y, alpha: 1.0 }); for (let i = this.trailPoints.length - 1; i >= 0; i--) { this.trailPoints[i].alpha -= deltaTime * 3; if (this.trailPoints[i].alpha <= 0) this.trailPoints.splice(i, 1); } while (this.trailPoints.length > 10) this.trailPoints.shift(); } this.animator.update(deltaTime); this.animationFrame = this.animator.getFrame(); super.update(deltaTime); const margin = 100; if (Math.abs(this.x) > (window as any).GAME_CONFIG.CANVAS_WIDTH + margin || Math.abs(this.y) > (window as any).GAME_CONFIG.CANVAS_HEIGHT + margin) this.shouldRemove = true; }
  render(ctx: CanvasRenderingContext2D): void { if (this.trail && this.trailPoints.length > 1) { ctx.save(); ctx.strokeStyle = this.color; ctx.lineWidth = this.size * 0.5; for (let i = 0; i < this.trailPoints.length - 1; i++) { const p = this.trailPoints[i]; const n = this.trailPoints[i + 1]; ctx.globalAlpha = p.alpha * 0.5; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(n.x, n.y); ctx.stroke(); } ctx.restore(); } super.render(ctx); }
  draw(ctx: CanvasRenderingContext2D): void { switch (this.weaponType) { case 'magic_wand': this.drawCactusFruit(ctx); break; case 'runetracer': this.drawChair(ctx); break; case 'king_bible': this.drawChicken(ctx); break; case 'axe': this.drawPita(ctx); break; case 'knife': this.drawStarOfDavid(ctx); break; default: this.drawGeneric(ctx); } }
  private drawCactusFruit(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#2d3436'; for (let i = 0; i < 4; i++) { const ang = (i / 4) * Math.PI * 2; const x = Math.cos(ang) * this.size * 0.8; const y = Math.sin(ang) * this.size * 0.8; ctx.fillRect(x - 0.5, y - 1.5, 1, 3); } }
  private drawChair(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = '#ffffff'; ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.fillRect(-this.size * 0.8, -this.size * 0.6, this.size * 1.6, this.size * 0.8); ctx.strokeRect(-this.size * 0.8, -this.size * 0.6, this.size * 1.6, this.size * 0.8); ctx.fillRect(-this.size * 0.8, -this.size, this.size * 1.6, this.size * 0.4); ctx.strokeRect(-this.size * 0.8, -this.size, this.size * 1.6, this.size * 0.4); }
  private drawChicken(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(0, 0, this.size * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(-this.size * 0.6, -this.size * 0.4, this.size * 0.4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#ffa502'; ctx.fillRect(-this.size, -this.size * 0.5, this.size * 0.3, this.size * 0.2); }
  private drawPita(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = '#deb887'; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#8b7355'; ctx.fillRect(-this.size * 0.5, -this.size * 0.2, this.size, this.size * 0.4); }
  private drawStarOfDavid(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = '#0038b8'; ctx.beginPath(); ctx.moveTo(0, -this.size); ctx.lineTo(this.size * 0.8, this.size * 0.4); ctx.lineTo(-this.size * 0.8, this.size * 0.4); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(0, this.size); ctx.lineTo(-this.size * 0.8, -this.size * 0.4); ctx.lineTo(this.size * 0.8, -this.size * 0.4); ctx.closePath(); ctx.fill(); }
  private drawGeneric(ctx: CanvasRenderingContext2D): void { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); }
}

declare global {
  interface Window {
    Entity: typeof EntityTS;
    Player: typeof PlayerTS;
    Enemy: typeof EnemyTS;
    Pickup: typeof PickupTSTS;
    Projectile: typeof ProjectileTS;
  }
}
(window as any).Entity = EntityTS;
(window as any).Player = PlayerTS;
(window as any).Enemy = EnemyTS;
(window as any).Pickup = PickupTSTS;
(window as any).Projectile = ProjectileTS;

export {};


